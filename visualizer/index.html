<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Habbo Agent Hotel</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        body { 
            margin: 0; 
            background: #1a1a1a; 
            overflow: hidden; 
            font-family: 'VT323', monospace; 
            image-rendering: pixelated;
        }
        
        /* Habbo-style UI Container */
        #ui-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 120px;
            background: #dedede;
            border-top: 4px solid #fff;
            box-shadow: 0 -4px 0 #999;
            display: flex;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
        }

        .habbo-btn {
            background: #efefef;
            border: 2px solid #fff;
            border-right-color: #999;
            border-bottom-color: #999;
            padding: 10px 20px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            color: #000;
            margin-right: 10px;
            cursor: pointer;
            text-transform: uppercase;
        }
        .habbo-btn:active {
            border: 2px solid #999;
            border-right-color: #fff;
            border-bottom-color: #fff;
            transform: translate(2px, 2px);
        }

        #chat-history {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            height: 400px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #000;
            border-radius: 8px;
            padding: 10px;
            overflow-y: auto;
            font-family: 'Verdana', sans-serif;
            font-size: 11px;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.2);
            z-index: 90;
        }

        .chat-bubble {
            background: #fff;
            border-radius: 15px;
            padding: 5px 10px;
            margin-bottom: 5px;
            border: 1px solid #ccc;
            position: relative;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }
        .chat-bubble b { color: #d35400; }
        
        #room-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: #1a6fa3;
            color: white;
            padding: 10px;
            border: 2px solid #fff;
            border-radius: 4px;
            font-family: 'Verdana', sans-serif;
            font-size: 12px;
            box-shadow: 2px 2px 0 #000;
        }
    </style>
</head>
<body>

<div id="room-info">
    <b>Agent Hotel Lobby</b><br>
    Occupants: <span id="occupant-count">0</span>
</div>

<div id="chat-history">
    <div style="text-align: center; color: #666; border-bottom: 1px solid #ccc; padding-bottom: 5px; margin-bottom: 5px;">Chat History</div>
    <div id="chat-content"></div>
</div>

<div id="ui-container">
    <div class="habbo-btn">Navigator</div>
    <div class="habbo-btn">Catalog</div>
    <div class="habbo-btn">Inventory</div>
    <div style="flex-grow: 1;"></div>
    <div style="font-size: 20px; color: #333;">System: <span id="sys-status">ONLINE</span></div>
</div>

<script>
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight - 120, // Leave room for UI
    pixelArt: true,
    backgroundColor: '#95a5a6', // Grey background like outside the room
    scene: { preload: preload, create: create, update: update }
};

const game = new Phaser.Game(config);

// Isometric Config
const TILE_W = 64;
const TILE_H = 32;
const MAP_SIZE = 10; 
const OFFSET_X = window.innerWidth / 2;
const OFFSET_Y = 100;

let agentSprites = {};
let lastChatTime = "";

function preload() {
    // We will generate textures procedurally to avoid external dependency issues
    // and to get that specific "Habbo" look
}

function create() {
    // 1. Generate Textures
    generateTextures(this);

    // 2. Draw Room (Floor + Walls)
    drawRoom(this);

    // 3. Start Polling
    this.time.addEvent({ delay: 1000, callback: fetchState, callbackScope: this, loop: true });
}

function update() {
    // Sort depth by Y position for correct isometric occlusion
    this.children.list.forEach(child => {
        if (child.type === 'Container' || child.type === 'Image') {
            // Simple depth sorting: lower on screen = closer to camera
            child.setDepth(child.y);
        }
    });
}

function generateTextures(scene) {
    // Floor Tile (Diamond)
    const graphics = scene.make.graphics({ x: 0, y: 0, add: false });
    
    // Top face
    graphics.fillStyle(0x95a5a6); // Light grey
    graphics.beginPath();
    graphics.moveTo(32, 0);
    graphics.lineTo(64, 16);
    graphics.lineTo(32, 32);
    graphics.lineTo(0, 16);
    graphics.closePath();
    graphics.fill();
    
    // Left face (Thickness)
    graphics.fillStyle(0x7f8c8d); // Darker
    graphics.beginPath();
    graphics.moveTo(0, 16);
    graphics.lineTo(32, 32);
    graphics.lineTo(32, 36); // 4px thick
    graphics.lineTo(0, 20);
    graphics.closePath();
    graphics.fill();

    // Right face (Thickness)
    graphics.fillStyle(0xbdc3c7); // Lighter
    graphics.beginPath();
    graphics.moveTo(64, 16);
    graphics.lineTo(32, 32);
    graphics.lineTo(32, 36);
    graphics.lineTo(64, 20);
    graphics.closePath();
    graphics.fill();
    
    // Highlight border
    graphics.lineStyle(1, 0xffffff, 0.2);
    graphics.strokePath();

    graphics.generateTexture('floor_tile', 64, 40);

    // Wall Tile (Vertical)
    graphics.clear();
    graphics.fillStyle(0xbdc3c7); // Wall color
    graphics.fillRect(0, 0, 32, 120);
    graphics.lineStyle(2, 0x95a5a6);
    graphics.strokeRect(0, 0, 32, 120);
    // Pattern
    graphics.lineStyle(1, 0xffffff, 0.3);
    for(let i=0; i<120; i+=20) {
        graphics.moveTo(0, i);
        graphics.lineTo(32, i);
    }
    graphics.strokePath();
    graphics.generateTexture('wall_tile', 32, 120);

    // Agent (Habbo-like blob)
    graphics.clear();
    // Body
    graphics.fillStyle(0xe67e22); // Skin
    graphics.fillRect(10, 10, 12, 12); // Head
    graphics.fillStyle(0x3498db); // Shirt
    graphics.fillRect(8, 22, 16, 14);
    graphics.fillStyle(0x2c3e50); // Pants
    graphics.fillRect(10, 36, 12, 14);
    // Outline
    graphics.lineStyle(2, 0x000000);
    graphics.strokeRect(10, 10, 12, 12);
    graphics.strokeRect(8, 22, 16, 14);
    graphics.strokeRect(10, 36, 12, 14);
    
    graphics.generateTexture('agent_base', 32, 64);
}

function drawRoom(scene) {
    // Draw Floor
    for (let x = 0; x < MAP_SIZE; x++) {
        for (let y = 0; y < MAP_SIZE; y++) {
            const isoX = (x - y) * TILE_W/2 + OFFSET_X;
            const isoY = (x + y) * TILE_H/2 + OFFSET_Y;
            
            scene.add.image(isoX, isoY, 'floor_tile');
        }
    }

    // Draw Walls (Back Left and Back Right)
    for (let i = 0; i < MAP_SIZE; i++) {
        // Left Wall (along Y axis where X=0)
        let wx = (0 - i) * TILE_W/2 + OFFSET_X - 32;
        let wy = (0 + i) * TILE_H/2 + OFFSET_Y - 60;
        scene.add.image(wx, wy, 'wall_tile').setDepth(wy - 1000); // Always behind

        // Right Wall (along X axis where Y=0)
        let rx = (i - 0) * TILE_W/2 + OFFSET_X + 32;
        let ry = (i + 0) * TILE_H/2 + OFFSET_Y - 60;
        // Flip for right wall perspective
        let wall = scene.add.image(rx, ry, 'wall_tile');
        wall.setFlipX(true);
        wall.setDepth(ry - 1000);
    }
}

async function fetchState() {
    try {
        const response = await fetch('http://localhost:8000/state');
        const data = await response.json();
        
        if(data.agents) {
            updateAgents(data.agents);
            document.getElementById('occupant-count').innerText = data.agents.length;
            document.getElementById('sys-status').innerText = "ONLINE";
            document.getElementById('sys-status').style.color = "#2ecc71";
        }
        if(data.chat_history) {
            updateChatHistory(data.chat_history);
        }
    } catch (e) {
        console.error(e);
        document.getElementById('sys-status').innerText = "OFFLINE";
        document.getElementById('sys-status').style.color = "#e74c3c";
    }
}

function updateAgents(agents) {
    const scene = game.scene.scenes[0];
    
    // Cleanup
    const currentNames = agents.map(a => a.name);
    Object.keys(agentSprites).forEach(name => {
        if (!currentNames.includes(name)) {
            agentSprites[name].container.destroy();
            delete agentSprites[name];
        }
    });

    agents.forEach(agent => {
        const gridX = agent.coordinates.x;
        const gridY = agent.coordinates.y;
        
        // Map 5x5 grid to 10x10 room
        const roomX = gridX * 2;
        const roomY = gridY * 2;

        const targetX = (roomX - roomY) * TILE_W/2 + OFFSET_X;
        const targetY = (roomX + roomY) * TILE_H/2 + OFFSET_Y - 20;

        if (agentSprites[agent.name]) {
            // Move
            const entity = agentSprites[agent.name];
            scene.tweens.add({
                targets: entity.container,
                x: targetX,
                y: targetY,
                duration: 800,
                ease: 'Power2'
            });
            
            // Update Chat Bubble above head
            if (agent.last_message && agent.last_message !== "...") {
                showOverheadBubble(scene, entity, agent.last_message);
            }

        } else {
            // Create
            const container = scene.add.container(targetX, targetY);
            
            // Shadow
            const shadow = scene.add.ellipse(0, 28, 24, 12, 0x000000, 0.3);
            
            // Sprite
            const sprite = scene.add.image(0, 0, 'agent_base');
            // Tint based on name hash to give variety
            const tint = stringToColor(agent.name);
            sprite.setTint(tint);

            // Name Tag
            const nameTag = scene.add.text(0, -40, agent.name, {
                fontFamily: 'Verdana',
                fontSize: '10px',
                color: '#000',
                backgroundColor: '#ffffffaa',
                padding: { x: 2, y: 1 }
            }).setOrigin(0.5);

            container.add([shadow, sprite, nameTag]);
            agentSprites[agent.name] = { container, sprite };
        }
    });
}

function showOverheadBubble(scene, entity, text) {
    // Don't spam bubbles
    if (entity.currentBubble) return;

    const bubble = scene.add.container(0, -70);
    const bg = scene.add.graphics();
    const txt = scene.add.text(0, 0, text, {
        fontFamily: 'Verdana',
        fontSize: '10px',
        color: '#000',
        align: 'center',
        wordWrap: { width: 120 }
    }).setOrigin(0.5);

    const bounds = txt.getBounds();
    bg.fillStyle(0xffffff, 1);
    bg.lineStyle(1, 0x000000, 1);
    bg.fillRoundedRect(-bounds.width/2 - 5, -bounds.height/2 - 5, bounds.width + 10, bounds.height + 10, 5);
    bg.strokeRoundedRect(-bounds.width/2 - 5, -bounds.height/2 - 5, bounds.width + 10, bounds.height + 10, 5);

    bubble.add([bg, txt]);
    entity.container.add(bubble);
    entity.currentBubble = bubble;

    // Float and fade
    scene.tweens.add({
        targets: bubble,
        y: -90,
        alpha: 0,
        delay: 3000,
        duration: 1000,
        onComplete: () => {
            bubble.destroy();
            entity.currentBubble = null;
        }
    });
}

function updateChatHistory(history) {
    const container = document.getElementById('chat-content');
    // Only update if new messages
    if (history.length > 0 && history[0].time !== lastChatTime) {
        container.innerHTML = "";
        // Server sends newest first (DESC). Reverse to show oldest -> newest (Chat log style)
        const sortedHistory = [...history].reverse();
        
        sortedHistory.forEach(h => {
            const div = document.createElement('div');
            div.className = 'chat-bubble';
            div.innerHTML = `<b>${h.agent}:</b> ${h.message}`;
            container.appendChild(div);
        });
        lastChatTime = history[0].time;
        // Auto scroll to bottom
        document.getElementById('chat-history').scrollTop = document.getElementById('chat-history').scrollHeight;
    }
}

function stringToColor(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = str.charCodeAt(i) + ((hash << 5) - hash);
    }
    let c = (hash & 0x00FFFFFF).toString(16).toUpperCase();
    return '0x' + "00000".substring(0, 6 - c.length) + c;
}
</script>
</body>
</html>
